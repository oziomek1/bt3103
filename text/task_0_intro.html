<html>
<p><strong>What is OOP?</strong></p><ul><li>Object oriented programming is a way of programming where code is bundled together into what is known as objects</li><li>This way of coding helps avoid <em>spaghetti</em> code, or just code with loose ends, functions, and such all mixed together. </li>
<li>We can group code together with methods, variables, and properties. Thus, we can more easily reuse code</li></ul><p><strong>Some basic definitions:</strong></p><p><strong>Classes:</strong></p><ul><li>A collection of methods and variables. Essentially a blueprint/template that defines its properties and functions </li></ul><p><strong>Objects:</strong> </p><ul><li><strong>Instances of classes.</strong> Objects are what users can actually interact with in their code. </li><li><em>Classes provide structure, an idea, while objects are instances of classes that we can actually interact with</em> </li></ul><p><strong>Methods</strong> </p><ul><li>Functions/actions of what each class can do</li></ul><p><strong>Let&#39;s teach through an example:</strong> a class human</p><ul><li>Every human has their own specific attributes. These attributes include a name, age, gender, height, weight, and many other qualities. We all eat, talk, and sleep</li><li>While you and I have different names and such, we use the same general attributes since we are both humans. <strong>We both use the same general blueprint of a human</strong>  </li><li>In this case, a human is a <strong>Class</strong> while you and I are <strong>instances</strong>, or objects, of the <strong>class Human</strong>. What we can do, such as sleeping, are <strong>methods</strong></li></ul><p><strong>Let&#39;s put that into code:</strong></p><ul><li>First, we have to create the <em>blueprint</em> of a Human. We do this by using the keyword <em>class</em>:  </li></ul>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span><span class="hljs-params">()</span>:</span>
</code></pre><ul>
<li>Next, what do all humans possess? We have to now define a human’s attributes/properties. Let’s start with how to keep track of <strong>each</strong> human’s attributes. <pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>(): </span>
  def__init__(<span class="hljs-keyword">self</span>, name, age, gender): 
      <span class="hljs-keyword">self</span>.name = name
      <span class="hljs-keyword">self</span>.age = age
      <span class="hljs-keyword">self</span>.gender = gender
</code></pre></li><li>Every time we create a human, it will have their own unique attributes. For this example, our blueprint of a human will have a name, age, and gender. </li><li><strong>In coding terms:</strong> We use <strong>def<strong>init</strong>(self, <em>instance attributes</em>):</strong> to define the <strong>instance (unique) attributes</strong> of every <strong>instance</strong> of class Human. We start out with <em>self</em> in the parameters to refer explicitly to a particular instance (or a particular human) </li><li>We always start instance attributes with the keyword <em>self</em>, which refers to each specific instance of a human. It helps keep track of all the attributes per each human instance. </li><li><strong>So for example:</strong> we both have an age, a name, and a gender since we are both humans however they are different for the both of us. The keyword <em>self</em> helps us objects keep track of our own name, age, and gender. </li><li>The lines under <strong>def__init()</strong> help define what each instance attribute should equal when creating an instance <strong>(object)</strong> of the class </li><li><strong>To help explain these lines</strong>, let’s create an instance of the class Human. We’ll call him Jit. He is a male who is 21 years old: </li></ul>
<pre><code>Jit = Human<span class="hljs-comment">(*Jit*, 21, *male*)</span>
</code></pre><ul><li>Jit is an <strong>object</strong>, or an <strong>instance</strong> of the <strong>class Human</strong></li><li><em>self.name</em> refers to a particular instance of the human class. In this case, it refers to Jit’s name. </li><li><em>name</em> refers to what value we give it with this particular instance of the <strong>class Human</strong>. Here, we assigned the object Jit with the name <em>Jit</em></li><li><p>So self.name = name means that for each instance of Human class, set that instance’s name (self.name) to whatever value is passed into the instance (name). This is the same for both age and gender. <strong>So Jit is a human named Jit, who is 21 years old and is male.</strong></p></li><li><p>So what about common characteristics all humans possess, such as our species or amount of fingers we have? This is what we call <strong>class attribute</strong>, which hold true for all classes <strong>no matter what</strong>: </p></li></ul>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>: </span>

    species = ‘mammal’

    def__init__(<span class="hljs-keyword">self</span>, name, age, gender): 
         <span class="hljs-keyword">self</span>.name = name
         <span class="hljs-keyword">self</span>.age = age
         <span class="hljs-keyword">self</span>.gender = gender
</code></pre><ul><li>All humans are mammals. You and I are instances of the class Human, but we are both mammals. There is no disputing that.  </li><li><strong>How about what we can do?</strong> You and I both eat, so there should be a <strong>method</strong> for that </li></ul>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>: </span>

    species = ‘mammal’

    def__init_<span class="hljs-number">_</span>(<span class="hljs-keyword">self</span>, name, age, gender): 
         <span class="hljs-keyword">self</span>.name = name
         <span class="hljs-keyword">self</span>.age = age
         <span class="hljs-keyword">self</span>.gender = gender 

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>:
         <span class="hljs-keyword">if</span> foodexists = <span class="hljs-symbol">True:</span>
              consumeFood()
</code></pre><ul><li><strong>def eat()</strong> defines a <strong>method</strong> within the human class. In this case, it’s to define eating. We can call these <strong>methods</strong> by using the <strong>objects</strong> we created earlier</li><li>So if Jit wants to eat, we do this: </li></ul>
<pre><code><span class="hljs-selector-tag">Jit</span><span class="hljs-selector-class">.eat</span>()
</code></pre><ul><li><strong>In this course, the class Game will create a class Snake object to interact with</strong></li></ul><p><strong><em>Components of OOP:</em></strong> </p><p><strong>Encapsulation:</strong> </p><ul><li>Grouping related variables and functions together into one object. This is essentially what classes do. </li><li>So earlier when we made class Human with all its properties and methods, that was encapsulation</li><li><strong>In this course, class Snake will have properties such as length and functions that control its movement (turn_left, turn_right, turn_down, turn_up)</strong></li></ul><p><strong>Inheritance:</strong></p><ul><li><p>A way to reuse code. Derived attributes and behaviors from another class without writing it out again. Think of it as a child inheriting characteristics of a parent, while having their own unique traits. </p></li><li><p><strong>Example:</strong> a student is a type of human. A student has the same properties and actions (methods) as a human. </p></li><li>We can create a child class by inserting the parent class name in its parameters. In this case, the student class will inherit from the human class. </li></ul>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Student</span>(<span class="hljs-type">Human</span>):</span>
</code></pre><ul><li>What is special about inheritance is that we can <strong>add even more methods and attributes</strong> on top of the class we are deriving from. </li><li>So a student may also have a class ID or major as well as more actions such as studying</li></ul>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-title">Human</span>):</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name, age, gender, ID, major)</span></span>: 
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.age = age
        <span class="hljs-keyword">self</span>.gender = gender  
        **<span class="hljs-keyword">self</span>.ID = ID**
        **<span class="hljs-keyword">self</span>.major = major**

    **<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:**</span>
        **<span class="hljs-keyword">if</span> work = <span class="hljs-symbol">True:</span>**
            **readBooks()**
            **writeThesis()**
</code></pre><ul><li>If we don&#39;t want to add additional methods to the child class, we can use pass</li><li><strong>In this course, we will use the parent class Square, which displays all the squares on our screen, to derive child classes such as class Cell</strong></li></ul><p><em>Note: the following components are a bit more conceptual and are harder to come up with examples</em> </p><p><strong>Abstraction:</strong> </p><ul><li>Hides the internal implementation details from users. </li></ul><p><strong>Example: think of a coffee machine</strong></p><ul><li>You may not know exactly how it works, but you do see the buttons on the machine and what they do. You know how to make your coffee </li><li>Similarly, users just need to know which methods are available to call and which inputs are needed to trigger certain actions. However, they do not need to know the exact functions within each class or how they call one another. </li></ul><p><strong>Polymorphism:</strong></p><ul><li>Ability to process objects differently depending on their data type or class. More specifically, it is the ability to redefine methods for derived classes. <strong>Example: let’s say there is a class Shape</strong></li><li>Polymorphism enables the programmer to define different area methods for any number of derived classes, such as circles, rectangles and triangles. </li><li>No matter what shape an object is, applying the area method to it will return the correct results by using the correct formulas per shape.</li></ul><p><strong>Here is a summary of how the course will proceed:</strong></p><ul><li><strong>We will be teaching you the concepts of OOP through building Snake!</strong></li></ul><ol><li><p>What are classes/what is encapsulation? <em>Creating the class Square</em> </p></li><li><p>What is inheritance? <em>Creating the class Cell</em></p></li></ol><p><strong>More class practice: <em>Creating the snacks, the snake, and the game that will run all the code!</em></strong></p><ol><li><p><em>class Snack and def draw</em></p></li><li><p><em>class Snake</em></p><ul><li>def getLength</li><li>def movement</li><li>def add_cell</li></ul></li><li><p><em>class Game</em></p></li></ol><ul><li>def check_collide (when does the snake die?)</li><li>def check_eat (how to check if the snake ate the snack)<ul><li>def start (starting the game up!) </li></ul></li></ul><ol><li>def intialize(putting it all together!)</li></ol><p><strong>Stuff outside the game</strong></p><ol><li>Abstraction in Snake</li><li><p>What inputs does the user need to know to play the game?</p></li><li><p>Polymorphism in Snake</p></li><li>Different types of snacks, invisible snakes, and different point values in a newer version. </li></ol></html>