Nice work getting this far! This is our final lesson, polymorphism in OOP

Simply put, polymorphism allows same-name functions to be used differently depending on the class or object.

Here is an example with a new type of snake added into the game:


Polymorphic classes:

class Snake():
    def movement(self):
        return "I move in straight lines"
 
class otherSnake():
    def movement(self):
        return "I move diagonally"
 
s1 = Snake()
s2 = otherSnake()
 
s1.movement()
>> "I move in straight lines"
s2.movement()
>> "I move diagonally"


What is happening?

* Despite these classes sharing the same method name, movement, polymorphism allows the computer to keep track of which movement method to use depending on what object is calling it.

* Polymorphism can also be carried out through inheritance. A coder can rewrite methods inherited, a process known as method overdrive. Here is an example of this with a new type of snack added to the game:


Polymorphism with inheritance and method overdrive:

score = 0 
 
class Snack():
    def increase_score(self):
    global score
        score += 1
    return score 
 
 
class specialSnack(Snack)
    def increase_score(self):
    global score
        score += 3
        return score
 
s1 = Snack()
s1.increase_score() 
>> 1
**resetting score to 0**
s2 = specialSnack()
s2.increase_score() 
>> 3


What is happening?

* specialSnack has modified the inherited increase_score method from the parent class Snack

* Now, when we call the method increase_score from objects of these classes, the score will increment differently